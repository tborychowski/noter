<div class="editor {$mode}">
	{#if $markedNote}
	<form on:submit="save(event)">
		<div class="editor-header">
			<div class="editor-header-row view">
				<span class="note-title">{$markedNote.title || ''}</span>
				<div class="flex-filler"></div>
				<div class="dates">
					created {timeAgo($markedNote.created_at)}<br>
					updated {timeAgo($markedNote.updated_at)}
				</div>
				<button type="button" class="btn-icon ion-md-create btn-edit" on:click="edit($markedNote)" title="Edit (e)"></button>
			</div>
			<div class="editor-header-row edit">
				<label>Folder:</label>
				<input class="note-folder-input"
					placeholder="folder"
					ref:folder
					bind:value="note.folder"
					on:keydown="onkeydown(event)">
				<div class="flex-filler"></div>
				<button type="submit" class="btn-icon ion-md-checkmark btn-save success" title="Save (Enter)"></button>
				{#if note.id}
					<button type="button" class="btn-icon ion-md-trash btn-remove danger" on:click="del(note.id)" title="Move to bin"></button>
				{/if}
				<button type="button" class="btn-icon ion-md-close btn-cancel" on:click="cancel()" title="Cancel (Esc)"></button>
			</div>
			<div class="editor-header-row edit">
				<input class="note-title-input"
					placeholder="New note"
					ref:title
					bind:value="note.title"
					on:keydown="onkeydown(event)">
			</div>
		</div>

		{#if $mode === 'view'}
			<div class="scroller" tabindex="0">
				<div class="note-text">
					{#await $markedNote.markedText}
						Loading...
					{:then noteText}
						{@html noteText}
					{/await}
				</div>
			</div>
		{:else}
			<div class="scroller">
				<textarea ref:text bind:value="note.text" on:keydown="onkeydown(event)"></textarea>
			</div>
		{/if}
	</form>
	{/if}
</div>


<script>
import {Data, Store, EVENT} from '../data';
import {timeAgo} from '../util';

export default {
	store: () => Store,
	data () {
		return { note: {} }
	},
	helpers: {
		timeAgo
	},
	oncreate () {
		this.store.on('state', ({ current, previous, changed }) => {
			if (changed.note && current.note) {
				if (!current.note.id) this.edit();
			}
		});

		EVENT.on(EVENT.notes.new, this.newNote.bind(this));
		EVENT.on(EVENT.notes.del, this.del.bind(this));
		EVENT.on(EVENT.edit.start, this.edit.bind(this));
		EVENT.on(EVENT.edit.check, this.checkEditMode.bind(this));
		EVENT.on(EVENT.focus.editor, this.focusEditor.bind(this));
		EVENT.on(EVENT.focus.editorView, this.focusEditorView.bind(this));
	},
	methods: {
		onkeydown (ev) {
			if (this.store.get().mode === 'edit') {
				if (ev.key === 'Escape') {
					ev.preventDefault();
					ev.stopPropagation();
					this.cancel();
				}
				else if (ev.key === 'ArrowDown') {
					if (ev.target.matches('.note-folder-input')) this.refs.title.focus();
					else if (ev.target.matches('.note-title-input')) this.refs.text.focus();
				}
				else if (ev.key === 'ArrowUp') {
					if (ev.target.matches('.note-title-input')) this.refs.folder.focus();
					// else if (ev.target.matches('.note-title-input')) this.refs.text.focus();
				}
				else if (ev.key === 'Enter' && (ev.metaKey || ev.ctrlKey)) this.save();
			}
		},

		newNote () {
			const {mode, folder} = this.store.get();
			if (mode !== 'view') return this.focusEditor();
			const note = { title: '', text: '', folder: folder || '' };
			this.store.set({ note });
		},

		checkEditMode () {
			if (this.store.get().mode !== 'view') this.focusEditor();
		},

		focusEditor () {
			document.querySelector('.note-folder-input').select();
		},

		focusEditorView () {
			document.querySelector('.editor .scroller').focus();
		},

		edit () {
			const {mode, note} = this.store.get();
			if (mode !== 'edit') {
				this.store.set({ mode: 'edit' });
				this.set({ note: Object.assign({}, note) });
				setTimeout(() => this.refs.title.select(), 100);
			}
		},

		cancel () {
			const note = this.get().note;
			const noNote = (!note || !note.id);
			this.store.set({ mode: 'view' });

			if (noNote) this.store.set({ note: null });
			else this.focusEditorView();
		},

		save (e) {
			if (e) e.preventDefault();
			let note = this.get().note;
			Data.Notes.save(note).then(res => {
				if (res.id) note = res;
				this.updateNoteInStore(note);
				this.cancel();
				this.store.set({ note, folder: note.folder });
			});
		},

		updateNoteInStore (note) {
			const notes = this.store.get().notes;
			const idx = notes.findIndex(n => n.id === note.id);
			if (idx > -1) notes[idx] = note;
			else notes.push(note);
			this.store.set({ notes, note });
		},

		del (id) {
			if (!id) id = this.store.get().note.id;
			if (!id) return;
			const notes = this.store.get().notes;
			const idx = notes.findIndex(n => n.id === id);
			const note = notes[idx];
			if (window.confirm(`Are you sure you wish to delete "${note.title}"`)) {
				const delfn = (note.deleted_at ? 'del' : 'bin');
				Data.Notes[delfn](id).then(res => {
					this.close();
					if (idx > -1) notes.splice(idx, 1);
					this.store.set({ notes });
				});
			}
		},

		close () {
			this.store.set({ mode: 'view', note: null });
		}
	}
};
</script>
